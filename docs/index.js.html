<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a><ul class='members'><li data-type='method'><a href="Base.html#avatar">avatar</a></li><li data-type='method'><a href="Base.html#discriminator">discriminator</a></li><li data-type='method'><a href="Base.html#id">id</a></li><li data-type='method'><a href="Base.html#tag">tag</a></li><li data-type='method'><a href="Base.html#username">username</a></li></ul></li><li><a href="Bot.html">Bot</a><ul class='methods'><li data-type='method'><a href="Bot.html#invite">invite</a></li><li data-type='method'><a href="Bot.html#support">support</a></li><li data-type='method'><a href="Bot.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="Bot.html#avatar">avatar</a></li><li data-type='method'><a href="Bot.html#backgroundColor">backgroundColor</a></li><li data-type='method'><a href="Bot.html#bot">bot</a></li><li data-type='method'><a href="Bot.html#clientID">clientID</a></li><li data-type='method'><a href="Bot.html#discriminator">discriminator</a></li><li data-type='method'><a href="Bot.html#github">github</a></li><li data-type='method'><a href="Bot.html#guildCount">guildCount</a></li><li data-type='method'><a href="Bot.html#hasAdvertisements">hasAdvertisements</a></li><li data-type='method'><a href="Bot.html#id">id</a></li><li data-type='method'><a href="Bot.html#inviteNoPerms">inviteNoPerms</a></li><li data-type='method'><a href="Bot.html#inviteURL">inviteURL</a></li><li data-type='method'><a href="Bot.html#isApproved">isApproved</a></li><li data-type='method'><a href="Bot.html#isFeatured">isFeatured</a></li><li data-type='method'><a href="Bot.html#isVerified">isVerified</a></li><li data-type='method'><a href="Bot.html#isWebsiteBot">isWebsiteBot</a></li><li data-type='method'><a href="Bot.html#library">library</a></li><li data-type='method'><a href="Bot.html#owner">owner</a></li><li data-type='method'><a href="Bot.html#owners">owners</a></li><li data-type='method'><a href="Bot.html#prefix">prefix</a></li><li data-type='method'><a href="Bot.html#secondaryOwners">secondaryOwners</a></li><li data-type='method'><a href="Bot.html#serverCount">serverCount</a></li><li data-type='method'><a href="Bot.html#shortDescription">shortDescription</a></li><li data-type='method'><a href="Bot.html#supportCode">supportCode</a></li><li data-type='method'><a href="Bot.html#supportURL">supportURL</a></li><li data-type='method'><a href="Bot.html#tag">tag</a></li><li data-type='method'><a href="Bot.html#upvotes">upvotes</a></li><li data-type='method'><a href="Bot.html#upvotesPast24Hours">upvotesPast24Hours</a></li><li data-type='method'><a href="Bot.html#upvotesPastMonth">upvotesPastMonth</a></li><li data-type='method'><a href="Bot.html#url">url</a></li><li data-type='method'><a href="Bot.html#username">username</a></li><li data-type='method'><a href="Bot.html#vanity">vanity</a></li><li data-type='method'><a href="Bot.html#widget">widget</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#edit">edit</a></li><li data-type='method'><a href="Client.html#fetchBot">fetchBot</a></li><li data-type='method'><a href="Client.html#fetchSelf">fetchSelf</a></li><li data-type='method'><a href="Client.html#fetchUser">fetchUser</a></li><li data-type='method'><a href="Client.html#fetchUserBots">fetchUserBots</a></li><li data-type='method'><a href="Client.html#fetchWidget">fetchWidget</a></li><li data-type='method'><a href="Client.html#fetchWidgetSelf">fetchWidgetSelf</a></li><li data-type='method'><a href="Client.html#isVerified">isVerified</a></li><li data-type='method'><a href="Client.html#isVerifiedSelf">isVerifiedSelf</a></li><li data-type='method'><a href="Client.html#postWebhook">postWebhook</a></li><li data-type='method'><a href="Client.html#setGuilds">setGuilds</a></li></ul><ul class='members'><li data-type='method'><a href="Client.html#.Classes">Classes</a></li><li data-type='method'><a href="Client.html#.endpoint">endpoint</a></li></ul></li><li><a href="ClientOptions.html">ClientOptions</a><ul class='members'><li data-type='method'><a href="ClientOptions.html#.default">default</a></li><li data-type='method'><a href="ClientOptions.html#botID">botID</a></li><li data-type='method'><a href="ClientOptions.html#client">client</a></li><li data-type='method'><a href="ClientOptions.html#log">log</a></li><li data-type='method'><a href="ClientOptions.html#secret">secret</a></li><li data-type='method'><a href="ClientOptions.html#token">token</a></li></ul></li><li><a href="FetchError.html">FetchError</a></li><li><a href="FetchOptions.html">FetchOptions</a><ul class='members'><li data-type='method'><a href="FetchOptions.html#normal">normal</a></li><li data-type='method'><a href="FetchOptions.html#specified">specified</a></li><li data-type='method'><a href="FetchOptions.html#stringify">stringify</a></li></ul></li><li><a href="PostOptions.html">PostOptions</a><ul class='members'><li data-type='method'><a href="PostOptions.html#botID">botID</a></li><li data-type='method'><a href="PostOptions.html#guildCount">guildCount</a></li><li data-type='method'><a href="PostOptions.html#token">token</a></li></ul></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method'><a href="User.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="User.html#avatar">avatar</a></li><li data-type='method'><a href="User.html#background">background</a></li><li data-type='method'><a href="User.html#bio">bio</a></li><li data-type='method'><a href="User.html#discriminator">discriminator</a></li><li data-type='method'><a href="User.html#id">id</a></li><li data-type='method'><a href="User.html#isAdmin">isAdmin</a></li><li data-type='method'><a href="User.html#isMod">isMod</a></li><li data-type='method'><a href="User.html#isVerifiedDeveloper">isVerifiedDeveloper</a></li><li data-type='method'><a href="User.html#tag">tag</a></li><li data-type='method'><a href="User.html#url">url</a></li><li data-type='method'><a href="User.html#user">user</a></li><li data-type='method'><a href="User.html#username">username</a></li><li data-type='method'><a href="User.html#website">website</a></li></ul></li><li><a href="WebhookPostOptions.html">WebhookPostOptions</a><ul class='members'><li data-type='method'><a href="WebhookPostOptions.html#botID">botID</a></li><li data-type='method'><a href="WebhookPostOptions.html#secret">secret</a></li><li data-type='method'><a href="WebhookPostOptions.html#userID">userID</a></li><li data-type='method'><a href="WebhookPostOptions.html#votes">votes</a></li></ul></li><li><a href="WidgetFetchOptions.html">WidgetFetchOptions</a><ul class='members'><li data-type='method'><a href="WidgetFetchOptions.html#height">height</a></li><li data-type='method'><a href="WidgetFetchOptions.html#width">width</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Fetch = require('node-fetch');
const util = require('util') // eslint-disable-line
const endpoint = 'https://botsfordiscord.com/api';
const ClientOptions = require('./structures/ClientOptions.js').ClientOptions;
const FetchError = require('./structures/FetchError.js').FetchError;
const FetchOptions = require('./structures/FetchOptions.js').FetchOptions;
const Bot = require('./structures/Bot.js').Bot;
const User = require('./structures/User.js').User;
const WidgetFetchOptions = require('./structures/WidgetFetchOptions.js').WidgetFetchOptions;
const WebhookPostOptions = require('./structures/WebhookPostOptions.js').WebhookPostOptions;
const PostOptions = require('./structures/PostOptions.js').PostOptions;

const warn = require('./util/warn.js').warn;
const bufferToObject = require('./util/bufferToObject.js').bufferToObject;

class Client {
    /**
     * Initializes the API wrapper.
     * @param {ClientOptions} [options=ClientOptions.default] Client Options.
     */
    constructor(options = ClientOptions.default) {
        /**
         * @ignore
         * @type {ClientOptions}
         */
        this.options;
        this.edit(options, true); // Note from the Developer: DO NOT TOUCH!!!!!!!
    }

    /**
     * By the way, if you are reading this, this won't run if you have options.log disabled.
     * @param {*} message The message to console log.
     * @private
     */
    _log(message) {
        if (this.options.log) console.log(message);
    }

    /**
     * Parses a buffer into a JS object, and returns true if it can, otherwise false.
     * @param {Buffer} buffer The buffer to check if it can be returned as an object or not.
     * @returns {Boolean} Whether or not the buffer can be parsed as a JS object.
     * @private
     */
    _parse(buffer) {
        return bufferToObject(buffer);
    }

    /**
     * Outputs red text in the console. Kool stuff.
     * @param {*} message The message to console log as RED.
     * @private
     */
    _warn(message) {
        warn(message);
    }

    /**
     * Change a value of the object.
     * @param {ClientOptions} [options={}] Client Options for change.
     * @param {Boolean} [preset=false] Whether or not to have preset options.
     * @returns {this}
     * @example
     * console.log(Client.edit({ log: false }));
     */
    edit(options = ClientOptions.default, preset = false) {
        if (!options) throw new ReferenceError('options must be defined.');
        if (options !== Object(options) || options instanceof Array) throw new TypeError('options must be an object.');
        if (options.token &amp;&amp; typeof options.token !== 'string') throw new TypeError('options.token must be a string.');
        if (options.botID &amp;&amp; typeof options.botID !== 'string') throw new TypeError('options.botID must be a string.');
        if (options.log &amp;&amp; typeof options.log !== 'boolean') throw new TypeError('options.log must be a boolean value.');

        this.options = new ClientOptions(options, preset ? ClientOptions.default : this.options);

        return this;
    }

    /**
     * Post your server count to your bot. Bot ID is supplied ID from initialization.
     * @param {PostOptions} [options={}] Post Options.
     * @returns {Promise&lt;Object>} Returns a message.
     */
    setGuilds(options = {}) {
        if (options !== Object(options) || options instanceof Array) throw new TypeError('options must be an object.');
        const Options = new PostOptions(options, this.options);
        if (!Options.token) throw new ReferenceError('POSTing server count requires a token to be set.');
        if (!Options.botID) throw new ReferenceError('POSTing server count requires a bot ID to be set.');
        if (!Options.guildCount) throw new ReferenceError('options.guildCount must be supplied; Not needed if you supply a valid client on initialization.');
        if (typeof Options.guildCount !== 'number') throw new TypeError('options.guildCount must be a number.');
        const size = { server_count: Options.guildCount };
        return new Promise((resolve, reject) => {
            Fetch(`${endpoint}/bot/${Options.botID}`, { method: 'POST', headers: { Authorization: Options.token, 'Content-Type': 'application/json' }, body: JSON.stringify(size) })
                .then(async body => {
                    const resolved = await body.json();
                    resolve(resolved);
                })
                .catch(reject);
        });
    }

    /**
     * Fetch a bot from the list.
     * @param {String} botID The bot ID to fetch
     * @param {FetchOptions} [options={}] Only supply if you want to get a specific value, etc. "verified" or "name" (Disclaimer: This does not detect non-existant values)
     * @returns {Promise&lt;Bot>} Returns the fetched bot data.
     */
    fetchBot(botID, options = {}) {
        if (!botID) throw new ReferenceError('The bot ID must be supplied.');
        if (typeof botID !== 'string') throw new TypeError('The bot ID must be a string.');
        return new Promise((resolve, reject) => {
            Fetch(`${endpoint}/bot/${botID}`)
                .then(async body => {
                    const bot = await body.json();
                    if (bot.message) throw new FetchError(bot.message);
                    const Options = new FetchOptions(options);
                    if (Options.normal) {
                        const resolved = Options.specified ? bot[Options.specified] : bot;
                        this._log(resolved);
                        resolve(resolved);
                    } else {
                        const BfdBot = Options.stringify ? new Bot(bot).toString() : new Bot(bot);
                        const resolved = Options.specified ? BfdBot[Options.specified] : BfdBot;
                        this._log(resolved);
                        resolve(resolved);
                    }
                })
                .catch(reject);
        });
    }

    /**
     * Fetch a bot using the ID supplied on initialization.
     * @param {FetchOptions} [options={}] Only supply if you want to get a specific value, etc. "verified" or "name" (Disclaimer: This does not detect non-existant values)
     * @returns {Promise&lt;Bot>} Returns the fetched bot data.
     */
    fetchSelf(options = {}) {
        if (!this.options.botID) throw new ReferenceError('ClientOptions.botID is non-existent.');
        return this.fetchBot(this.options.botID, options);
    }

    /**
     * Fetch a user that has logged on to the list.
     * @param {String} userID The user ID to fetch.
     * @param {FetchOptions} [options={}] A specific thing to get, like
     * @returns {Promise&lt;User>} Returns the user data.
     * @example
     * Client.fetchUser('235593018332282884')
     *  .then(user => console.log(user.username))
     *  .catch(console.error);
     */
    fetchUser(userID, options = {}) {
        if (!userID) throw new ReferenceError('The user ID must be supplied.');
        if (typeof userID !== 'string') throw new TypeError('The user ID must be a string.');
        return new Promise((resolve, reject) => {
            Fetch(`${endpoint}/user/${userID}`)
                .then(async body => {
                    const user = await body.json();
                    if (user.message) throw new FetchError(user.message);
                    const Options = new FetchOptions(options);
                    if (Options.normal) {
                        const resolved = Options.specified ? user[Options.specified] : user;
                        this._log(resolved);
                        resolve(resolved);
                    } else {
                        const BfdUser = Options.stringify ? new User(user).toString() : new User(user);
                        const resolved = Options.specified ? BfdUser[Options.specified] : BfdUser;
                        this._log(resolved);
                        resolve(resolved);
                    }
                })
                .catch(reject);
        });
    }

    /**
     * Fetches a user's bots' IDs.
     * @param {String} userID The user ID to get their bots from.
     * @returns {Promise&lt;Array&lt;String>>} An array of the bot IDs the user owns.
     */
    fetchUserBots(userID) {
        if (!userID) throw new ReferenceError('userID must be defined.');
        if (typeof userID !== 'string') throw new TypeError('userID must be a string.');
        return new Promise((resolve, reject) => {
            Fetch(`${endpoint}/user/${userID}/bots`)
                .then(async body => {
                    const info = await body.json();
                    if (info.message) throw new FetchError(info.message);
                    const Bots = info.bots;
                    this._log(Bots);
                    resolve(Bots);
                })
                .catch(reject);
        });
    }

    /**
     * Fetch a widget of a bot on the list.
     * @param {String} botID The bot ID to fetch.
     * @param {WidgetFetchOptions} options Widget Fetch Options.
     * @returns {Promise&lt;Buffer>} The widget buffer.
     * @example
     * const fs = require('fs');
     *
     * Client.fetchWidget('463803888072523797')
     *  .then(widget => fs.writeFileSync('widget.jpeg', widget))
     *  .catch(console.error);
     */
    fetchWidget(botID, options = {}) {
        if (!botID) throw new ReferenceError('botID must be defined.');
        if (typeof botID !== 'string') throw new TypeError('botID must be a string.');
        if (options !== Object(options) || options instanceof Array) throw new TypeError('options must be an object.');
        return new Promise((resolve, reject) => {
            const Options = new WidgetFetchOptions(options);
            if (Options.width &lt; 400 || Options.height &lt; 180) this._warn('Any widgets fetched with a requested size smaller than 400x180 may be distorted to an unknown level.');
            Fetch(`${endpoint}/bot/${botID}/widget${Options.width}${Options.height}`)
                .then(async widget => {
                    const Body = await widget.buffer();
                    if (this._parse(Body)) throw new FetchError(JSON.parse(Body).message);
                    this._log(Body);
                    resolve(Body);
                })
                .catch(reject);
        });
    }

    /**
     * Fetch the widget of the self bot.
     * @param {WidgetFetchOptions} options Widget Fetch Options
     * @returns {Promise&lt;Buffer>} The widget buffer.
     */
    fetchWidgetSelf(options = {}) {
        if (!this.options.botID) throw new ReferenceError('ClientOptions.botID is non-existent.');
        return this.fetchWidget(this.options.botID, options);
    }

    /**
     * Check if a bot is verified. Shorthand convenience function for this.fetchBot(botID, 'verified')
     * @param {String} botID I guess if you wanted to check if a bot was verified...you could use this...
     * @returns {Promise&lt;Boolean>} Returns true or false, depending if the bot is verified or not.
     */
    isVerified(botID) {
        if (!botID) throw new ReferenceError('botID must be defined.');
        if (typeof botID !== 'string') throw new TypeError('botID must be a string.');
        return new Promise((resolve, reject) => {
            this.fetchBot(botID, { specified: 'isVerified' })
                .then(resolve)
                .catch(reject);
        });
    }

    /**
     * Check if your own bot is verified.
     * @returns {Promise&lt;Boolean>} Returns true or false, depending if the bot is verified or not.
     */
    isVerifiedSelf() {
        if (!this.options.botID) throw new ReferenceError('this.options.botID must be defined.');
        return this.isVerified(this.options.botID);
    }

    /**
     * Tests posting to a webhook.
     * @param {WebhookPostOptions} options Webhook Post Options.
     * @returns {Object} An object containing an example.
     */
    postWebhook(options = {}) {
        if (options !== Object(options) || options instanceof Array) throw new TypeError('options must be an object.');
        const Options = new WebhookPostOptions(options);
        return new Promise((resolve, reject) => {
            const data = { user: Options.userID, bot: Options.botID, votes: Options.votes };
            Fetch(`${endpoint}/webhooktest`, { method: 'POST', headers: { Authorization: this.options.token }, body: JSON.stringify(data) })
                .then(async body => {
                    const webhook = await body.json();
                    resolve(webhook);
                })
                .catch(reject);
        });
    }

    /**
     * The Base URL for interacting with the site.
     * @returns {String} The Base URL.
     * @static
     */
    static get endpoint() {
        return endpoint;
    }

    /**
     * All of the Classes used.
     * @static
     */
    static get Classes() {
        return { Bot, ClientOptions, FetchOptions, PostOptions, User, WebhookPostOptions, WidgetFetchOptions };
    }
}

module.exports = Client;</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Nov 08 2018 19:06:39 GMT-0800 (Pacific Standard Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
